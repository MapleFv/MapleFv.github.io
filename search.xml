<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM垃圾回收详解</title>
    <url>/2022/05/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>👇👇👇👇👇</p>
<span id="more"></span>

<p><a name="In8Wl"></a></p>
<h1 id="minorGC-和-Full-GC区别"><a href="#minorGC-和-Full-GC区别" class="headerlink" title="minorGC 和 Full GC区别"></a>minorGC 和 Full GC区别</h1><p><a name="YG75B"></a></p>
<h1 id="1-揭开-JVM-内存分配与回收的神秘面纱"><a href="#1-揭开-JVM-内存分配与回收的神秘面纱" class="headerlink" title="1 揭开 JVM 内存分配与回收的神秘面纱"></a><br />1 揭开 JVM 内存分配与回收的神秘面纱</h1><hr>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）。</strong>从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong><br><a name="KBPke"></a></p>
<h2 id="1-1-对象优先在-eden-区分配"><a href="#1-1-对象优先在-eden-区分配" class="headerlink" title="1.1 对象优先在 eden 区分配"></a>1.1 对象优先在 eden 区分配</h2><hr>
<p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。<br />大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC<br><a name="uAXbe"></a></p>
<h2 id="1-2-大对象直接进入老年代"><a href="#1-2-大对象直接进入老年代" class="headerlink" title="1.2 大对象直接进入老年代"></a><br />1.2 大对象直接进入老年代</h2><hr>
<p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率<br><a name="zlFaD"></a></p>
<h2 id="1-3-长期存活的对象将进入老年代"><a href="#1-3-长期存活的对象将进入老年代" class="headerlink" title="1.3 长期存活的对象将进入老年代"></a>1.3 长期存活的对象将进入老年代</h2><hr>
<p><a name="tD6gQ"></a></p>
<h2 id="1-5-主要进行-gc-的区域"><a href="#1-5-主要进行-gc-的区域" class="headerlink" title="1.5 主要进行 gc 的区域"></a><br />1.5 主要进行 gc 的区域</h2><hr>
<p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：<br />部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（<strong>Minor GC</strong> &#x2F; Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（**Major GC **&#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（<strong>Mixed GC</strong>）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。等价于MajorGC<br><a name="somKl"></a></p>
<h2 id="1-6-空间分配担保"><a href="#1-6-空间分配担保" class="headerlink" title="1.6 空间分配担保"></a>1.6 空间分配担保</h2><hr>
<p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。<br><a name="lGcp1"></a></p>
<h1 id="2-对象已经死亡？"><a href="#2-对象已经死亡？" class="headerlink" title="2 对象已经死亡？"></a>2 对象已经死亡？</h1><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。<br><a name="varSy"></a></p>
<h2 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h2><hr>
<p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。<br><a name="VCdbZ"></a></p>
<h2 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a><br />2.2 可达性分析算法</h2><hr>
<p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。<br /><strong>哪些对象可以作为 GC Roots 呢？</strong></p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<p><strong>对象可以被回收，就代表一定会被回收吗？</strong><br />经可达性分析后不可达对象暂时处于“缓刑阶段”，要真正宣告一个对象死亡，要经历两个阶段，不可达是第一阶段，然后筛选，筛选的条件是此对象是否有必要执行 finalize 方法。被判定为需要执行的对象被放在一个队列中进行第二次标记，如果依然无法建立引用链，则会被真的回收，JDK9移除了finalize方法。<br><a name="maRPv"></a></p>
<h2 id="2-3-再谈引用"><a href="#2-3-再谈引用" class="headerlink" title="2.3 再谈引用"></a>2.3 再谈引用</h2><hr>
<p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p>
<ol>
<li><strong>强引用（StrongReference）</strong></li>
</ol>
<p>使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<ol start="2">
<li><strong>软引用（SoftReference）</strong></li>
</ol>
<p><strong>可有可无的生活用品。</strong>内存足够，垃圾回收器不会回收塔，如果内存不足就会回收。软引用可用来实现内存敏感的高速缓存。</p>
<ol start="3">
<li><strong>弱引用（WeakReference）</strong></li>
</ol>
<p><strong>可有可无的生活用品。</strong>弱引用与软引用的区别在于：只具有弱引用的对象拥有<strong>更短暂的生命周期</strong>。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，<strong>都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br /><strong>4．虚引用（PhantomReference）</strong><br />虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<br /><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。<br /><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。<br />特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
<p><a name="Rv63N"></a></p>
<h1 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3 垃圾收集算法"></a>3 垃圾收集算法</h1><hr>
<p><a name="l2XXD"></a></p>
<h2 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h2><hr>
<p>先标记不需要被回收的对象，然后清除未标记的对象<br />这种垃圾收集算法会带来两个明显的问题：</p>
<ol>
<li><strong>效率问题</strong></li>
<li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong><br><a name="UxTof"></a><h2 id="3-2-标记-复制算法"><a href="#3-2-标记-复制算法" class="headerlink" title="3.2 标记-复制算法"></a><br />3.2 标记-复制算法</h2></li>
</ol>
<hr>
<p>为了解决效率问题，将内存分类大小相同的两块，每次使用其中的一块，当这一块内存使用完后，就将还存活的对象复制到另一块去，然后把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。<br><a name="Wsauu"></a></p>
<h2 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h2><hr>
<p>标记之后，让所有存活对象向一端移动，然后直接清理掉端边界以外的内存。<br><a name="og0c3"></a></p>
<h2 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a><br />3.4 分代收集算法</h2><hr>
<p>当前虚拟机的垃圾收集都采用分代收集算法。一般将 java 堆分为新生代和老年代，比如在<strong>新生代</strong>中，每次收集都会有<strong>大量对象死去</strong>，所以可以选择”<strong>标记-复制</strong>“算法，只需要付出<strong>少量对象的复制成本</strong>就可以完成每次垃圾收集。而<strong>老年代</strong>的对象<strong>存活几率是比较高</strong>的，而且没有额外的空间对它进行分配担保，所以我们必须选择<strong>“标记-清除”或“标记-整理”</strong>算法进行垃圾收集。<br><a name="xr1rN"></a></p>
<h1 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4 垃圾收集器"></a><br />4 垃圾收集器</h1><p>垃圾回收算法是方法论，垃圾收集器就是内存回收的具体实现。<br /><strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。<br><a name="Ex5Oi"></a></p>
<h2 id="4-1-Serial-收集器"><a href="#4-1-Serial-收集器" class="headerlink" title="4.1 Serial 收集器"></a>4.1 Serial 收集器</h2><hr>
<p>单线程收集器；<br />它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束；<br />新生代采用标记-复制算法，老年代采用标记-整理算法；<br />简单而高效（与其他收集器的单线程相比没有线程交互的开销）；<br />Client模式下的虚拟机首选；<br><a name="L9mOS"></a></p>
<h2 id="4-2-ParNew-收集器"><a href="#4-2-ParNew-收集器" class="headerlink" title="4.2 ParNew 收集器"></a><br />4.2 ParNew 收集器</h2><hr>
<p>Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样；<br />新生代采用标记-复制算法，老年代采用标记-整理算法；<br />Server 模式下的虚拟机的首选；<br />除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器）配合工作；<br />补充：</p>
<ul>
<li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上<br><a name="KeuVO"></a><h2 id="4-3-Parallel-Scavenge-收集器"><a href="#4-3-Parallel-Scavenge-收集器" class="headerlink" title="4.3 Parallel Scavenge 收集器"></a>4.3 Parallel Scavenge 收集器</h2></li>
</ul>
<hr>
<p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。<br /> <strong>那么它有什么特别之处呢？</strong><br />Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）<br />CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。<br /><strong>所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong><br />新生代采用标记-复制算法，老年代采用标记-整理算法。<br><a name="WPs2f"></a></p>
<h2 id="4-4-Serial-Old-收集器"><a href="#4-4-Serial-Old-收集器" class="headerlink" title="4.4.Serial Old 收集器"></a>4.4.Serial Old 收集器</h2><hr>
<p><strong>Serial 收集器的老年代版本</strong><br />它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。<br><a name="GjraW"></a></p>
<h2 id="4-5-Parallel-Old-收集器"><a href="#4-5-Parallel-Old-收集器" class="headerlink" title="4.5 Parallel Old 收集器"></a>4.5 Parallel Old 收集器</h2><hr>
<p><strong>Parallel Scavenge 收集器的老年代版本</strong>。</p>
<p><a name="K3LhP"></a></p>
<h2 id="4-6-CMS-收集器"><a href="#4-6-CMS-收集器" class="headerlink" title="4.6 CMS 收集器"></a>4.6 CMS 收集器</h2><hr>
<p>CMS（Concurrent Mark Sweep）以获取最短回收停顿时间为目标的收集器，第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线基本上程同时工作；适合注重用户体验的情景；<br />从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”</strong>算法实现的；<br />运作更复杂：<strong>初始标记、并发标记、重新标记、并发清除</strong><br />主要优点：<strong>并发收集、低停顿</strong>。<br />缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong><br><a name="raalH"></a><h2 id="4-7-G1-收集器"><a href="#4-7-G1-收集器" class="headerlink" title="4.7 G1 收集器"></a>4.7 G1 收集器</h2></li>
</ul>
<hr>
<p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器<br />主要针对配备多个处理器及大容量内存的机器. <br />以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.<br />它具备以下特点：<strong>并行与并发、分代收集</strong>、<strong>空间整合</strong>（全局上是标记整理，局部是标记复制）<strong>可预测的停顿（</strong>建立可预测的停顿时间模型<strong>）</strong><br />G1 收集器的运作大致分为以下几个步骤：<strong>初始标记、并发标记、最终标记、筛选回收</strong><br />G1 收集器在后台维护了一个优先列表，根据Region划分区域，优先选择回收价值最大的区域回收(这也就是它的名字 Garbage-First 的由来) ；这也保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。<br><a name="hxdy7"></a></p>
<h2 id="4-8-ZGC-收集器"><a href="#4-8-ZGC-收集器" class="headerlink" title="4.8 ZGC 收集器"></a>4.8 ZGC 收集器</h2><hr>
<p>ZGC对标记复制做了重大改进<br />在 ZGC 中出现 Stop The World 的情况会更少！</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Quick Start</title>
    <url>/2022/05/07/Quick%20Start/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Win10下Hexo博客搭建教程，及阿里云服务器部署实战</title>
    <url>/2022/05/07/Win10%E4%B8%8BHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%EF%BC%8C%E5%8F%8A%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>🍈🍈🍈🍈🍈</p>
<span id="more"></span>



<h2 id="1-在本地计算机安装Hexo环境"><a href="#1-在本地计算机安装Hexo环境" class="headerlink" title="1. 在本地计算机安装Hexo环境"></a>1. 在本地计算机安装Hexo环境</h2><h2 id="2-服务端准备工作"><a href="#2-服务端准备工作" class="headerlink" title="2. 服务端准备工作"></a>2. 服务端准备工作</h2><h2 id="3-Hexo博客的阿里云部署"><a href="#3-Hexo博客的阿里云部署" class="headerlink" title="3. Hexo博客的阿里云部署"></a>3. Hexo博客的阿里云部署</h2><h2 id="4-其它配置"><a href="#4-其它配置" class="headerlink" title="4. 其它配置"></a>4. 其它配置</h2>]]></content>
      <tags>
        <tag>blogs</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将部署在GitHub的博客绑定指定域名</title>
    <url>/2022/05/22/%E5%A6%82%E4%BD%95%E5%B0%86%E9%83%A8%E7%BD%B2%E5%9C%A8GitHub%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E6%8C%87%E5%AE%9A%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<p>🔔 🔔 🔔 🔔 🔔</p>
<span id="more"></span>

<p>前提：我已经将Hexo博客部署在了GitHub，HTTPS为：<a href="https://github.com/MapleFv/MapleFv.github.io.git">https://github.com/MapleFv/MapleFv.github.io.git</a></p>
<p><a href="https://imgtg.com/image/hZOVa"><img src="https://i.imgtg.com/2022/05/22/hZOVa.png" alt="hZOVa.png"></a><a name="YEdIs"></a></p>
<h1 id="1-申请域名"><a href="#1-申请域名" class="headerlink" title="1. 申请域名"></a>1. 申请域名</h1><blockquote>
<p>我用的聚名网，网站地址<a href="https://www.juming.com/">https://www.juming.com/</a><br>这里注册、登录、实名认证…乱起八糟的全部省略，切记一定要<strong>绑定邮箱</strong>，后续通知都是发到邮箱里</p>
</blockquote>
<p><a name="rcRf2"></a></p>
<h2 id="1-1-查询域名"><a href="#1-1-查询域名" class="headerlink" title="1.1 查询域名"></a>1.1 查询域名</h2><p><a href="https://imgtg.com/image/hZooS"><img src="https://i.imgtg.com/2022/05/22/hZooS.png" alt="hZooS.png"></a></p>
<h2 id="1-2-立即注册"><a href="#1-2-立即注册" class="headerlink" title="1.2 立即注册"></a>1.2 立即注册<br /></h2><p><a href="https://imgtg.com/image/hZqrN"><img src="https://i.imgtg.com/2022/05/22/hZqrN.png" alt="hZqrN.png"></a></p>
<h2 id="1-3-付钱"><a href="#1-3-付钱" class="headerlink" title="1.3 付钱"></a>1.3 付钱</h2><p><a name="or9v4"></a></p>
<h2 id="1-4-点击“我的域名”（进入正题）"><a href="#1-4-点击“我的域名”（进入正题）" class="headerlink" title="1.4 点击“我的域名”（进入正题）"></a>1.4 点击“我的域名”（进入正题）</h2><p><a href="https://imgtg.com/image/hZ5GC"><img src="https://i.imgtg.com/2022/05/22/hZ5GC.png" alt="hZ5GC.png"></a></p>
<h2 id="1-5-点击“模板管理”"><a href="#1-5-点击“模板管理”" class="headerlink" title="1.5 点击“模板管理”"></a>1.5 点击“模板管理”</h2><p><a href="https://imgtg.com/image/hZB3L"><img src="https://i.imgtg.com/2022/05/22/hZB3L.png" alt="hZB3L.png"></a></p>
<h2 id="1-6-添加域名模板"><a href="#1-6-添加域名模板" class="headerlink" title="1.6 添加域名模板"></a>1.6 添加域名模板</h2><p><a href="https://imgtg.com/image/hZUii"><img src="https://i.imgtg.com/2022/05/22/hZUii.png" alt="hZUii.png"></a></p>
<h2 id="1-7-等待审核"><a href="#1-7-等待审核" class="headerlink" title="1.7 等待审核"></a>1.7 等待审核</h2><p><a href="https://imgtg.com/image/hZWtX"><img src="https://i.imgtg.com/2022/05/22/hZWtX.png" alt="hZWtX.png"></a></p>
<h2 id="1-8-进入域名管理页面，点击“域名解析”"><a href="#1-8-进入域名管理页面，点击“域名解析”" class="headerlink" title="1.8 进入域名管理页面，点击“域名解析”"></a>1.8 进入域名管理页面，点击“域名解析”<br /></h2><p>点击添加记录</p>
<blockquote>
<p>1、主机记录：就是比如你要让你的域名可以不带www的也可以访问maplefv.top，主机记录为@<br />2、记录类型：防止本地IP有变化，最好选择CNAME类型<br />3、记录值：你的仓库名<br />4、线路类型：无需特殊设置，请保持默认即可！</p>
</blockquote>
<p><a href="https://imgtg.com/image/hZb2t"><img src="https://i.imgtg.com/2022/05/22/hZb2t.png" alt="hZb2t.png"></a></p>
<p>至此，域名准备工作结束<br><a name="mJjVW"></a></p>
<h1 id="2-给git仓库绑定域名"><a href="#2-给git仓库绑定域名" class="headerlink" title="2. 给git仓库绑定域名"></a>2. 给git仓库绑定域名</h1><p>进入仓库，选择Settings,找到Pages，在Custom domain部分添加域名，最后点击“Save”结束<br /></p>
<p><a name="OWwbz"></a></p>
<h1 id="3-本地配置CNAME"><a href="#3-本地配置CNAME" class="headerlink" title="3. 本地配置CNAME"></a>3. 本地配置CNAME</h1><p><a href="https://imgtg.com/image/hZzgj"><img src="https://i.imgtg.com/2022/05/22/hZzgj.png" alt="hZzgj.png"></a></p>
<p><a name="sIZ5Q"></a></p>
<h1 id="4-配置完成，测试"><a href="#4-配置完成，测试" class="headerlink" title="4. 配置完成，测试"></a>4. 配置完成，测试</h1><p>打开浏览器，输入maplefv.top（你的域名）</p>
<p><a href="https://imgtg.com/image/hZFVp"><img src="https://i.imgtg.com/2022/05/22/hZFVp.png" alt="hZFVp.png"></a></p>
]]></content>
      <tags>
        <tag>blogs</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统常见面试题总结</title>
    <url>/2022/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>🍍🍍🍍🍍🍍</p>
<span id="more"></span>

<p><a name="aiUvF"></a></p>
<h1 id="1-操作系统基础"><a href="#1-操作系统基础" class="headerlink" title="1. 操作系统基础"></a>1. 操作系统基础</h1><hr>
<p><a name="cIAad"></a></p>
<h2 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h2><hr>
<ol>
<li>操作系统（OS）是管理计算机硬件与软件资源的程序，是计算机的基石</li>
<li>操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源</li>
<li>操作系统存在屏蔽了硬件层的复杂性</li>
<li>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备管理，文件系统的管理以及应用程序的管理<br><a name="r6wnS"></a><h2 id="1-2-系统调用，什么是系统调用"><a href="#1-2-系统调用，什么是系统调用" class="headerlink" title="1.2 系统调用，什么是系统调用"></a>1.2 系统调用，什么是系统调用</h2></li>
</ol>
<hr>
<p>介绍系统调用之前，先了解一下用户状态和系统状态<br />根据进程访问资源的特点，，我们可以将进程在系统上的运行分为两个级别：</p>
<ol>
<li>用户态（user mode）：用户态运行的进程可以直接读取用户程序的数据。</li>
<li>系统态（Kernel mode）：可以简单的理解系统运行的进程或程序几乎可以访问你计算机的任何 资源，不受限制</li>
</ol>
<p>说了用户态和系统态之后，那什么是系统调用呢？<br />我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！<br />也就是说在我们运行的用户程序中，范式与系统态级别的资源有关的操作（如文件管理、进程管理、内存管理等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。<br />这些系统调用按功能大致分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能；</li>
<li>文件管理。完成文件的读、些、创建及删除等功能；</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能；</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能；</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。<br><a name="w9bAb"></a><h1 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2. 进程和线程"></a>2. 进程和线程</h1></li>
</ul>
<hr>
<p><a name="Ug6TM"></a></p>
<h2 id="2-1-进程和线程的区别"><a href="#2-1-进程和线程的区别" class="headerlink" title="2.1 进程和线程的区别"></a>2.1 进程和线程的区别</h2><hr>
<p>一个进程可以有多个线程，多个线程共享进程的堆和方法区（JDK1.8之后的元空间）资源，但是每个线程都有自己的程序计数器、虚拟机栈、本地方法栈</p>
<p><a name="Ljg1v"></a></p>
<h2 id="2-2-进程有哪几种状态"><a href="#2-2-进程有哪几种状态" class="headerlink" title="2.2 进程有哪几种状态?"></a>2.2 进程有哪几种状态?</h2><hr>
<p>一般把进程分为5种状态，这一点和线程很像</p>
<ul>
<li>创建状态（new）</li>
<li>就绪状态（ready）</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）</li>
<li>结束状态（terminated）</li>
</ul>
<p><a name="KIphd"></a></p>
<h2 id="2-3-进程间的通信方式"><a href="#2-3-进程间的通信方式" class="headerlink" title="2.3 进程间的通信方式"></a>2.3 进程间的通信方式</h2><hr>
<ol>
<li>管道&#x2F;匿名管道（Pipes）</li>
<li>有名管道（Names Pipes） 先进先出</li>
<li>信号（Signal）</li>
<li>消息队列（Message Queuing）管道与消息队列都是先进先出，不同的是匿名管道存在文件中，有名管道存在于磁盘中，而消息队列存放在内核中。消息队列克服了信号承载信息量少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</li>
<li>信号量（Semaphores）</li>
<li>共享内存（Shared memory）</li>
<li>套接字（Sockets）</li>
</ol>
<p><a name="cZMbv"></a></p>
<h2 id="2-4-线程间的同步的方式"><a href="#2-4-线程间的同步的方式" class="headerlink" title="2.4 线程间的同步的方式"></a>2.4 线程间的同步的方式</h2><hr>
<p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步方式：</p>
<ol>
<li>互斥量（Mutex） Java中的synchronized关键字和各种Lock都是这种机制</li>
<li>信号量（Semaphore）</li>
<li>事件（Event）</li>
</ol>
<p><a name="KXXDd"></a></p>
<h2 id="2-5-进程的调度算法"><a href="#2-5-进程的调度算法" class="headerlink" title="2.5 进程的调度算法"></a><br />2.5 进程的调度算法</h2><hr>
<p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大CPU利用率</p>
<ol>
<li>先到先服务（FCFS）</li>
<li>短作业优先（SJF）</li>
<li>时间片轮转（RR）</li>
<li>多级反馈队列：既能使高优先级的作业得到响应又能使短作业（进程）迅速完成</li>
<li>优先级调度，相同优先级使用FCFS<br><a name="xIvPr"></a><h2 id="2-6-什么是死锁"><a href="#2-6-什么是死锁" class="headerlink" title="2.6 什么是死锁"></a><br />2.6 什么是死锁</h2></li>
</ol>
<hr>
<p>多个进程&#x2F;线程同时被阻塞，他们中的一个或全部都在等待某个资源被释放。由于进程&#x2F;线程被无限期地阻塞，因此程序不可能正常终止。<br><a name="zyRrv"></a></p>
<h2 id="2-7产生死锁的四个条件"><a href="#2-7产生死锁的四个条件" class="headerlink" title="2.7产生死锁的四个条件"></a><br />2.7产生死锁的四个条件</h2><hr>
<p>如果系统中以下四个条件<strong>同时成立</strong>，就能引起死锁：</p>
<ul>
<li>互斥：资源处于非共享模式</li>
<li>占有并等待</li>
<li>非抢占</li>
<li>循环等待</li>
</ul>
<p>2.8 解决死锁的方法</p>
<hr>
<p>预防<br />避免<br />检测<br />解除<br><a name="KfQFN"></a></p>
<h3 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h3><p>通过破坏死锁产生条件的第二条和第四条<br />1、<strong>静态分配策略</strong>：破坏占有并等待，在执行之前申请到他所需要的全部资源，并且知道他所要的资源都得到满足之后才开始执行；；<br />缺点：严重降低了资源利用率，可能造成一个进程占有了一些几乎不用的资源而使其他需要该资源的进程产生等待的情况。<br />2、<strong>层次分配策略</strong>：破坏循环等待，一个进程得某一次的一个资源后，只能再申请较高一层的资源，当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源<br /><strong>缺点：导致低效的进程运行和资源使用率</strong><br><a name="PLU3d"></a></p>
<h3 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a><br />死锁的避免</h3><p>我们将系统的状态分为安全状态和不安全状态；通过算法，其中最具代表性的避免死锁算法就是银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，银行家算法通过先试探分配给该进程资源，然后通过安全性算法判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入安全状态，就真分配资源给该进程。<br />缺点：要不断检测每个进程对各类资源的占用和申请情况，以及做安全性检查，需要花费较多的时间。</p>
<p><a name="Evn8Z"></a></p>
<h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><p>定时地运行一个“死锁检测”程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解决它。<br />死锁检测步骤：</p>
<ol>
<li>如果进程-资源分配图中无环路，则此时系统没有发生死锁</li>
<li>如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。</li>
<li>如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 <strong>既不阻塞又非独立的进程</strong> ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 <strong>消除所有的边</strong> ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 <strong>拓扑排序</strong>)</li>
</ol>
<p><a name="YgtY7"></a></p>
<h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><p>当死锁检测程序检测到存在死锁发生时，采取死锁接触操作，让系统从死锁状态中恢复过来，常用的接触死锁方法有以下四种：</p>
<ol>
<li>立即结束所有进程的执行，重新启动操作系统</li>
<li>撤销涉及死锁的进程，解除死锁后继续运行</li>
<li>逐个撤销涉及死锁的进程，回收其资源直至死锁解除</li>
<li>抢占资源<br><a name="s66jD"></a><h1 id="3-操作系统内存管理基础"><a href="#3-操作系统内存管理基础" class="headerlink" title="3. 操作系统内存管理基础"></a>3. 操作系统内存管理基础</h1><a name="M5iuG"></a><h2 id="3-1-操作系统的内存管理主要是做什么？"><a href="#3-1-操作系统的内存管理主要是做什么？" class="headerlink" title="3.1 操作系统的内存管理主要是做什么？"></a>3.1 操作系统的内存管理主要是做什么？</h2></li>
</ol>
<hr>
<p>操作系统的内存管理主要负责内存的分配与回收（malloc函数：申请内存，free函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情<br><a name="CK7pF"></a></p>
<h2 id="3-2-操作系统的内存管理机制了解吗？内存管理有哪几种方式"><a href="#3-2-操作系统的内存管理机制了解吗？内存管理有哪几种方式" class="headerlink" title="3.2 操作系统的内存管理机制了解吗？内存管理有哪几种方式?"></a>3.2 操作系统的内存管理机制了解吗？内存管理有哪几种方式?</h2><hr>
<p>内存管理机制简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>两种。连续分配管理方式指为一个用户程序分配一个连续的内存空间，常见的有<strong>块式管理</strong>。非连续分配管理方式指允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理和段式管理</strong><br /><strong>块式管理</strong>：如果程序运行需要内存的话，操作系统就分配给他一个内存块<br /><strong>页式管理</strong>：把主内存分为大小相等且固定的一页一页的形式，页较小，相比块式管理的划分力度更小，提高内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址<br /><strong>段式管理</strong>：页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。<br /><strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。<br><a name="G5c7k"></a></p>
<h2 id="3-3-快表和多级页表"><a href="#3-3-快表和多级页表" class="headerlink" title="3.3 快表和多级页表"></a>3.3 快表和多级页表</h2><hr>
<p>在分页内存管理中，很重要的两点是：</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大的问题。<br><a name="tsZ5I"></a><h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4>为了提高虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。</li>
</ol>
<p>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
<p><a name="IpocE"></a></p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。<br><a name="vPKeV"></a></p>
<h2 id="3-4-分页机制和分段机制的共同点和区别"><a href="#3-4-分页机制和分段机制的共同点和区别" class="headerlink" title="3.4 分页机制和分段机制的共同点和区别"></a>3.4 分页机制和分段机制的共同点和区别</h2><hr>
<ol>
<li><strong>共同点</strong> ：<ul>
<li>分页机制和分段机制都是为了提高内存利用率，减少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li><strong>区别</strong> ：<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要<br><a name="cFFyB"></a><h2 id="3-5-逻辑-虚拟-地址和物理地址"><a href="#3-5-逻辑-虚拟-地址和物理地址" class="headerlink" title="3.5 逻辑(虚拟)地址和物理地址"></a>3.5 逻辑(虚拟)地址和物理地址</h2></li>
</ul>
</li>
</ol>
<hr>
<p>比如C语言中指针里存储的数值就可以理解为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。<br><a name="bW4Np"></a></p>
<h2 id="3-6-CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#3-6-CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?"></a>3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?</h2><hr>
<p><strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong><br /><strong>如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p>
<p><a name="QJABV"></a></p>
<h1 id="四-虚拟内存"><a href="#四-虚拟内存" class="headerlink" title="四 虚拟内存"></a>四 虚拟内存</h1><p><a name="FvuKs"></a></p>
<h2 id="4-1-什么是虚拟内存-Virtual-Memory"><a href="#4-1-什么是虚拟内存-Virtual-Memory" class="headerlink" title="4.1 什么是虚拟内存(Virtual Memory)?"></a>4.1 什么是虚拟内存(Virtual Memory)?</h2><hr>
<p>虚拟内存可以让程序拥有超过系统物理内存大小的可用内存空间。<br />虚拟内存为每个进程提供了一个一致的、私有的地址空间，他让每个进程产生了一种自己在独享主存的错觉<br><a name="nmTAh"></a></p>
<h2 id="4-2-局部性原理"><a href="#4-2-局部性原理" class="headerlink" title="4.2 局部性原理"></a>4.2 局部性原理</h2><hr>
<p>局部性原理表现在以下两个方面：<br /><strong>时间局部性</strong><br /><strong>空间局部性</strong><br><a name="WndKk"></a></p>
<h2 id="4-3-虚拟存储器"><a href="#4-3-虚拟存储器" class="headerlink" title="4.3 虚拟存储器"></a>4.3 虚拟存储器</h2><hr>
<p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其它部分留在外存，就可以启动程序执行。当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大得多的存储器——<strong>虚拟存储器</strong>。<br><a name="rC3eY"></a></p>
<h2 id="4-4-虚拟内存的技术实现"><a href="#4-4-虚拟内存的技术实现" class="headerlink" title="4.4 虚拟内存的技术实现"></a>4.4 虚拟内存的技术实现</h2><hr>
<p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上虚拟内存的实现需要建立在离散分配的内存管理方式的基础上</strong><br />虚拟内存的实现有以下三种方式：<br /><strong>请求分页存储管理</strong> <br />建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。<br /><strong>请求分段存储管理</strong><br />建立在分段存储管理之上，增加了请求调段功能、分段置换功能。<br /><strong>请求段页式存储管理</strong><br />这里多说一下？很多人容易搞混<strong>请求分页</strong>与<strong>分页存储管理</strong>，两者有何不同呢？<br />请求分页存储管理不要求将作业全部地址空间同时装入主存，可提供虚拟内存<br />分页存储管理却不能提供</p>
<p>不管是上面那种实现方式，我们一般都需要：<br />一定容量的内存和外存<br />却也中断<br />虚拟地址空间</p>
<p><a name="kvh16"></a></p>
<h2 id="4-5-页面置换算法"><a href="#4-5-页面置换算法" class="headerlink" title="4.5 页面置换算法"></a>4.5 页面置换算法</h2><hr>
<p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。<br />发生缺页中断时，发现主存没有空闲页面，操作系统就必须在内存选择一个页面将其移出内存，一边为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法。<br /><strong>最佳（Optimal，OPT）页面置换算法</strong>,该算法无法实现。一般作为衡量其他置换算法的方法。<br /><strong>先进先出(first in first out，FIFO)页面置换算法</strong>，总是淘汰先进入内存的页面<br /><strong>最近最久未使用（Least Recently Used,LRU）页面置换算法</strong>。赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间T，总是淘汰T最大的<br />最少使用（Least Frequently Used）页面置换算法。选择在之前时期使用最少的页面作为淘汰页</p>
]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
</search>
